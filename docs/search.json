[
  {
    "objectID": "posts/容器资源监控/index.html",
    "href": "posts/容器资源监控/index.html",
    "title": "cadvisor + prometheus + grafana 容器资源监控",
    "section": "",
    "text": "为了准确测量软件运行所需资源，可以在 docker 容器中运行软件，并监控它的资源消耗。\n\n\n\n资源消耗图\n\n\n为了获取上图结果，我们需要下面三个程序：\n\ncAdvisor：用于收集正在运行的容器资源使用和性能信息。\nPrometheus：由于 cAdvisor 只展示两分钟的资源消耗结果，需要部署这个软件进行存储 cAdvisor 的结果。\nGrafana：开源可视化系统，可以对 Prometheus 存储的资源进行可视化。"
  },
  {
    "objectID": "posts/容器资源监控/index.html#简介",
    "href": "posts/容器资源监控/index.html#简介",
    "title": "cadvisor + prometheus + grafana 容器资源监控",
    "section": "",
    "text": "为了准确测量软件运行所需资源，可以在 docker 容器中运行软件，并监控它的资源消耗。\n\n\n\n资源消耗图\n\n\n为了获取上图结果，我们需要下面三个程序：\n\ncAdvisor：用于收集正在运行的容器资源使用和性能信息。\nPrometheus：由于 cAdvisor 只展示两分钟的资源消耗结果，需要部署这个软件进行存储 cAdvisor 的结果。\nGrafana：开源可视化系统，可以对 Prometheus 存储的资源进行可视化。"
  },
  {
    "objectID": "posts/容器资源监控/index.html#cadvisor-部署",
    "href": "posts/容器资源监控/index.html#cadvisor-部署",
    "title": "cadvisor + prometheus + grafana 容器资源监控",
    "section": "2 cAdvisor 部署",
    "text": "2 cAdvisor 部署\n对需要监控的主机启动如下容器：\nsudo docker run \\\n  --volume=/:/rootfs:ro \\\n  --volume=/var/run:/var/run:ro \\\n  --volume=/sys:/sys:ro \\\n  --volume=/var/lib/docker/:/var/lib/docker:ro \\\n  --volume=/dev/disk/:/dev/disk:ro \\\n  --publish=8080:8080 \\\n  --detach=true \\\n  --name=cadvisor \\\n  --privileged \\\n  --device=/dev/kmsg \\\n  gcr.io/cadvisor/cadvisor\n\n\n\n\n\n\nTip\n\n\n\n&lt;ip&gt; 记得更换为自己的 ip 地址。\n\n\ncAdvisor 默认在 8080 端口运行，主页面：http://&lt;ip&gt;:8080 。\nhttp://&lt;ip&gt;:8080/metrics 端口可以看到 prometheus 所需要的信息。"
  },
  {
    "objectID": "posts/容器资源监控/index.html#prometheus-部署",
    "href": "posts/容器资源监控/index.html#prometheus-部署",
    "title": "cadvisor + prometheus + grafana 容器资源监控",
    "section": "3 prometheus 部署",
    "text": "3 prometheus 部署\n当前文件夹下新建配置文件prometheus.yml：\n\n\nprometheus.yml\n\nscrape_configs:\n- job_name: cadvisor\n  scrape_interval: 5s\n  static_configs:\n  - targets:\n    - &lt;ip&gt;:8080\n\ndocker run --name prometheus -d \\\n    -p 9090:9090 \\\n    -v ./prometheus.yml:/etc/prometheus/prometheus.yml \\\n    prom/prometheus \\\n    --config.file=/etc/prometheus/prometheus.yml \\\n    --web.enable-lifecycle \\\n    --storage.tsdb.retention.time=15d\n\n# 参数解释\n--config.file，指定配置文件\n--storage.tsdb.path，指定数据存储目录\n--storage.tsdb.retention，指定数据过期时间，默认 15 天\n--query.max-concurrency，最大支持的并发查询量\n--web.enable-lifecycle，启用热加载\n打开网址：http://&lt;ip&gt;:9090/targets 看看是否采集正常。\n\n此时所有监控目标的状态都是 UP，表明 prometheus 可以正常获取到监控数据。"
  },
  {
    "objectID": "posts/容器资源监控/index.html#grafana-部署",
    "href": "posts/容器资源监控/index.html#grafana-部署",
    "title": "cadvisor + prometheus + grafana 容器资源监控",
    "section": "4 grafana 部署",
    "text": "4 grafana 部署\ndocker run -d --name=grafana -p 3000:3000 grafana/grafana\n\n4.1 使用\n打开网址：http://&lt;ip&gt;:3000，首次进入账号密码均为admin , 会提示修改密码。\n\n中文设置，个人资料中设置：\n\n\n\n添加 prometheus 数据源，在下图红框位置填写 prometheus 地址即可\n\n\n\n仪表板查看容器的相关资源\n\n\n导入仪表板\n\n\n\n选择 cAdvisor监控Pod的CPU、网络、IO以及内存等指标的一个模板ID：14282 ，点击加载按钮后选择刚刚的数据源即可。\n\n\n然后就可以查看容器资源监控的仪表板，如下所示："
  },
  {
    "objectID": "posts/容器资源监控/index.html#windowns-部署命令",
    "href": "posts/容器资源监控/index.html#windowns-部署命令",
    "title": "cadvisor + prometheus + grafana 容器资源监控",
    "section": "5 windowns 部署命令",
    "text": "5 windowns 部署命令\n\n构建 docker 网络, 使得容器之间互相访问\n\ndocker network create cadvisor\n\n部署程序\n\ndocker run --network cadvisor --volume=/:/rootfs:ro --volume=/var/run:/var/run:ro --volume=/sys:/sys:ro --volume=/var/lib/docker/:/var/lib/docker:ro --volume=/dev/disk/:/dev/disk:ro --publish=8080:8080 --detach=true --name=cadvisor --privileged --device=/dev/kmsg gcr.io/cadvisor/cadvisor\n\n\n# 查看容器的ip，prometheus.yml 填写对应的容器 ip 地址\ndocker inspect &lt;容器id&gt;\n\n# 按照上文，生成 prometheus.yml 配置文件\ndocker run --network cadvisor --name prometheus -d -p 9090:9090 -v $PWD\\prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus --config.file=/etc/prometheus/prometheus.yml --web.enable-lifecycle --storage.tsdb.retention.time=15d\n\ndocker run --network cadvisor -d --name=grafana -p 3000:3000 grafana/grafana\n\n\n\n资源消耗图"
  },
  {
    "objectID": "posts/quarto_blog/index.html",
    "href": "posts/quarto_blog/index.html",
    "title": "quarto 创建博客",
    "section": "",
    "text": "Quarto® 是在一款建立在pandoc上的开源的科学与技术排版系统，可以进行包含Python、R 、Julia、或 bash 等代码的自动化报告工作。\n\n\n\n这里推荐两个选择：\n\n按照官网 介绍下载安装即可。\n选择一个带 quarto 的 docker 镜像，我比较喜欢使用的是 rocker 项目的 tidyverse镜像。tidyverse镜像的基础镜像是rstudio 镜像，而目前新版本的rstudio 都会包含 quarto 软件。\n\n\nps: 我选择此镜像是顺便作为 R 方面开发的基础镜像。\n\n# pull 镜像\ndocker pull rocker/tidyverse:latest\n# 运行, 挂载自己本地的路径，我习惯将整个D盘挂载到镜像中。\ndocker run -d -ti -p 8787:8787 -e ROOT=TRUE -e PASSWORD=《你的密码》 -v 《本地路径，可以整个D盘》:《镜像目录》 rocker/tidyverse\n这样，你就可以直接打开浏览器，输入网址 localhost:8787 开启 Rstudio IDE。 默认用户名：rstudio \n\n\n\n\n没什么资源比官网的步骤更详细了\n\nhttps://quarto.org/docs/websites/website-blog.html\n\n\n\n\n\n网址前缀如：https://《用户名》.github.io 所示的网址就是使用的github-pages。\n\n首先在 github 新建一个名称为 https://《用户名》.github.io 的仓库。\n设置好仓库的pages选项，如下图所示：\n\n\n\n按照上面的步骤，博客项目下会有_quarto.yml 文件，修改下此文件的输出目录。\n\n\n\n_quarto.yml\n\nproject:\n  type: website\n  output-dir: docs\n\n\n将 .nojekyll 文件添加到存储库的根目录，告诉 GitHub Pages 不要使用 Jekyll（GitHub 默认站点生成工具）对已发布的站点进行其他处理：\n\n\n\nterminal\n\ntouch .nojekyll\n\n\n渲染网站并发布\n\n# quarto 渲染网站\nquarto render\n# 使用 git 将渲染好的网站发送到刚刚创建好的仓库中\ngit push"
  },
  {
    "objectID": "posts/quarto_blog/index.html#使用-quarto-创建自己的博客",
    "href": "posts/quarto_blog/index.html#使用-quarto-创建自己的博客",
    "title": "quarto 创建博客",
    "section": "",
    "text": "Quarto® 是在一款建立在pandoc上的开源的科学与技术排版系统，可以进行包含Python、R 、Julia、或 bash 等代码的自动化报告工作。\n\n\n\n这里推荐两个选择：\n\n按照官网 介绍下载安装即可。\n选择一个带 quarto 的 docker 镜像，我比较喜欢使用的是 rocker 项目的 tidyverse镜像。tidyverse镜像的基础镜像是rstudio 镜像，而目前新版本的rstudio 都会包含 quarto 软件。\n\n\nps: 我选择此镜像是顺便作为 R 方面开发的基础镜像。\n\n# pull 镜像\ndocker pull rocker/tidyverse:latest\n# 运行, 挂载自己本地的路径，我习惯将整个D盘挂载到镜像中。\ndocker run -d -ti -p 8787:8787 -e ROOT=TRUE -e PASSWORD=《你的密码》 -v 《本地路径，可以整个D盘》:《镜像目录》 rocker/tidyverse\n这样，你就可以直接打开浏览器，输入网址 localhost:8787 开启 Rstudio IDE。 默认用户名：rstudio \n\n\n\n\n没什么资源比官网的步骤更详细了\n\nhttps://quarto.org/docs/websites/website-blog.html\n\n\n\n\n\n网址前缀如：https://《用户名》.github.io 所示的网址就是使用的github-pages。\n\n首先在 github 新建一个名称为 https://《用户名》.github.io 的仓库。\n设置好仓库的pages选项，如下图所示：\n\n\n\n按照上面的步骤，博客项目下会有_quarto.yml 文件，修改下此文件的输出目录。\n\n\n\n_quarto.yml\n\nproject:\n  type: website\n  output-dir: docs\n\n\n将 .nojekyll 文件添加到存储库的根目录，告诉 GitHub Pages 不要使用 Jekyll（GitHub 默认站点生成工具）对已发布的站点进行其他处理：\n\n\n\nterminal\n\ntouch .nojekyll\n\n\n渲染网站并发布\n\n# quarto 渲染网站\nquarto render\n# 使用 git 将渲染好的网站发送到刚刚创建好的仓库中\ngit push"
  },
  {
    "objectID": "posts/granian_dash/index.html",
    "href": "posts/granian_dash/index.html",
    "title": "granian 部署 dash 生产环境",
    "section": "",
    "text": "相比使用 gunicorn 部署 dash 应用，具有更好的性能。性能比较文档：https://github.com/emmett-framework/granian/blob/master/benchmarks/vs.md\n\n\n下载 granian\n\npip install granian\n\ndash 示例代码\n\n\nimport dash\nfrom dash import html\n\napp = dash.Dash(__name__)\n\napp.layout = html.Div([\n    html.H1(\"Dash 示例\"),\n])\n\nserver = app.server # 这行代码需要包含\n\nif __name__ == '__main__':\n    app.run_server(debug=True)\n\n\n启动程序\n\ngranian --interface wsgi --workers 4 app:server\n\n\n\n\n\n\nTip\n\n\n\n–interface 参数用于指定应用程序接口类型，如服务器网关接口（WSGI）或异步服务器网关接口（ASGI）来运行。通常 flask 或者 Django 使用 wsgi，而 starlette 或 fastapi 构建的应用使用 asgi。\n\n\n\n\n想要自己重启 granian，可以向 granian 主进程发送HUP信号，这会导致 granian 平滑地重启所有工作进程，但不会关闭主进程。（适合在使用频率低的情况下，重启应用程序，而不影响其他人）\n\n查找主进程 pid\n\nps axjf | grep granian\nkill -HUP 1674\n\n\n\n使用方式: granian [选项] APP\n\n  APP  服务的应用目标。[必需]\n\n选项:\n  --host TEXT                     绑定的主机地址  [环境变量: GRANIAN_HOST; 默认: (127.0.0.1)]\n  --port INTEGER                  绑定的端口。[环境变量: GRANIAN_PORT; 默认: 8000]\n  --interface [asgi|asginl|rsgi|wsgi]\n                                  应用接口类型  [环境变量: GRANIAN_INTERFACE; 默认: (rsgi)]\n  --http [auto|1|2]               HTTP 版本  [环境变量: GRANIAN_HTTP; 默认: (auto)]\n  --ws / --no-ws                  启用websocket处理  [环境变量: GRANIAN_WEBSOCKETS; 默认: (启用)]\n  --workers INTEGER RANGE         工作进程数量  [环境变量: GRANIAN_WORKERS; 默认: 1; x&gt;=1]\n  --threads INTEGER RANGE         每个工作进程的线程数量  [环境变量: GRANIAN_THREADS; 默认: 1; x&gt;=1]\n  --blocking-threads INTEGER RANGE\n                                  每个工作进程的阻塞线程数量\n                                  [环境变量: GRANIAN_BLOCKING_THREADS; x&gt;=1]\n  --threading-mode [runtime|workers]\n                                  使用的线程模式  [环境变量: GRANIAN_THREADING_MODE; 默认: (workers)]\n  --loop [auto|asyncio|uvloop]    事件循环实现  [环境变量: GRANIAN_LOOP; 默认: (auto)]\n  --opt / --no-opt                启用循环优化  [环境变量: GRANIAN_LOOP_OPT; 默认: (禁用)]\n  --backlog INTEGER RANGE         全局最大连接等待数  [环境变量: GRANIAN_BACKLOG; 默认: 1024; x&gt;=128]\n  --backpressure INTEGER RANGE    每个工作进程并发处理的最大请求数  [环境变量: GRANIAN_BACKPRESSURE; 默认: (backlog/workers); x&gt;=1]\n  --http1-buffer-size INTEGER RANGE\n                                  设置HTTP/1连接的最大缓冲区大小  [环境变量: GRANIAN_HTTP1_BUFFER_SIZE; 默认: 417792; x&gt;=8192]\n  --http1-keep-alive / --no-http1-keep-alive\n                                  启用或禁用HTTP/1保持连接  [环境变量: GRANIAN_HTTP1_KEEP_ALIVE; 默认: (启用)]\n  --http1-pipeline-flush / --no-http1-pipeline-flush\n                                  聚合HTTP/1刷新以更好地支持管线化响应（实验性）  [环境变量: GRANIAN_HTTP1_PIPELINE_FLUSH; 默认: (禁用)]\n  --http2-adaptive-window / --no-http2-adaptive-window\n                                  设置是否对HTTP2使用自适应流控制  [环境变量: GRANIAN_HTTP2_ADAPTIVE_WINDOW; 默认: (禁用)]\n  --http2-initial-connection-window-size INTEGER\n                                  设置HTTP2的最大连接级流控制  [环境变量: GRANIAN_HTTP2_INITIAL_CONNECTION_WINDOW_SIZE; 默认: 1048576]\n  --http2-initial-stream-window-size INTEGER\n                                  设置HTTP2流级流控制的`SETTINGS_INITIAL_WINDOW_SIZE`选项\n                                  [环境变量: GRANIAN_HTTP2_INITIAL_STREAM_WINDOW_SIZE; 默认: 1048576]\n  --http2-keep-alive-interval INTEGER\n                                  设置应发送HTTP2 Ping帧以保持连接存活的间隔\n                                  [环境变量: GRANIAN_HTTP2_KEEP_ALIVE_INTERVAL]\n  --http2-keep-alive-timeout INTEGER\n                                  设置接收HTTP2保持连接ping的确认的超时时间\n                                  [环境变量: GRANIAN_HTTP2_KEEP_ALIVE_TIMEOUT; 默认: 20]\n  --http2-max-concurrent-streams INTEGER\n                                  设置HTTP2连接的SETTINGS_MAX_CONCURRENT_STREAMS选项  [环境变量: GRANIAN_HTTP2_MAX_CONCURRENT_STREAMS; 默认: 200]\n  --http2-max-frame-size INTEGER  设置HTTP2的最大帧大小  [环境变量: GRANIAN_HTTP2_MAX_FRAME_SIZE; 默认: 16384]\n  --http2-max-headers-size INTEGER\n                                  设置接收的头帧的最大大小\n                                  [环境变量: GRANIAN_HTTP2_MAX_HEADERS_SIZE; 默认: 16777216]\n  --http2-max-send-buffer-size INTEGER\n                                  设置每个HTTP/2流的最大写缓冲区大小  [环境变量: GRANIAN_HTTP2_MAX_SEND_BUFFER_SIZE; 默认: 409600]\n  --log / --no-log                启用日志记录  [环境变量: GRANIAN_LOG_ENABLED; 默认: (启用)]\n  --log-level [critical|error|warning|warn|info|debug]\n                                  日志级别  [环境变量: GRANIAN_LOG_LEVEL; 默认: (info)]\n  --log-config FILE               日志配置文件(json)  [环境变量: GRANIAN_LOG_CONFIG]\n  --access-log / --no-access-log  启用访问日志  [环境变量: GRANIAN_LOG_ACCESS_ENABLED; 默认: (禁用)]\n  --access-log-fmt TEXT           访问日志格式  [环境变量: GRANIAN_LOG_ACCESS_FMT]\n  --ssl-keyfile FILE              SSL密钥文件  [环境变量: GRANIAN_SSL_KEYFILE]\n  --ssl-certificate FILE          SSL证书文件  [环境变量: GRANIAN_SSL_CERTIFICATE]\n  --url-path-prefix TEXT          应用挂载的URL路径前缀  [环境变量: GRANIAN_URL_PATH_PREFIX]\n  --respawn-failed-workers / --no-respawn-failed-workers\n                                  启用意外退出的工作进程重生\n                                  [环境变量: GRANIAN_RESPAWN_FAILED_WORKERS; 默认: (禁用)]\n  --respawn-interval FLOAT        工作进程重生间隔秒数  [环境变量: GRANIAN_RESPAWN_INTERVAL; 默认: 3.5]\n  --reload / --no-reload          启用应用文件更改的自动重载（需要granian[reload]额外配置）\n                                  [环境变量: GRANIAN_RELOAD; 默认: (禁用)]\n  --process-name TEXT             设置进程的自定义名称（需要granian[pname]额外配置）  [环境变量: GRANIAN_PROCESS_NAME]\n  --version                       显示版本并退出。\n  --help                          显示这条帮助信息并退出。"
  },
  {
    "objectID": "posts/granian_dash/index.html#使用-granian-部署-dash",
    "href": "posts/granian_dash/index.html#使用-granian-部署-dash",
    "title": "granian 部署 dash 生产环境",
    "section": "",
    "text": "相比使用 gunicorn 部署 dash 应用，具有更好的性能。性能比较文档：https://github.com/emmett-framework/granian/blob/master/benchmarks/vs.md\n\n\n下载 granian\n\npip install granian\n\ndash 示例代码\n\n\nimport dash\nfrom dash import html\n\napp = dash.Dash(__name__)\n\napp.layout = html.Div([\n    html.H1(\"Dash 示例\"),\n])\n\nserver = app.server # 这行代码需要包含\n\nif __name__ == '__main__':\n    app.run_server(debug=True)\n\n\n启动程序\n\ngranian --interface wsgi --workers 4 app:server\n\n\n\n\n\n\nTip\n\n\n\n–interface 参数用于指定应用程序接口类型，如服务器网关接口（WSGI）或异步服务器网关接口（ASGI）来运行。通常 flask 或者 Django 使用 wsgi，而 starlette 或 fastapi 构建的应用使用 asgi。\n\n\n\n\n想要自己重启 granian，可以向 granian 主进程发送HUP信号，这会导致 granian 平滑地重启所有工作进程，但不会关闭主进程。（适合在使用频率低的情况下，重启应用程序，而不影响其他人）\n\n查找主进程 pid\n\nps axjf | grep granian\nkill -HUP 1674\n\n\n\n使用方式: granian [选项] APP\n\n  APP  服务的应用目标。[必需]\n\n选项:\n  --host TEXT                     绑定的主机地址  [环境变量: GRANIAN_HOST; 默认: (127.0.0.1)]\n  --port INTEGER                  绑定的端口。[环境变量: GRANIAN_PORT; 默认: 8000]\n  --interface [asgi|asginl|rsgi|wsgi]\n                                  应用接口类型  [环境变量: GRANIAN_INTERFACE; 默认: (rsgi)]\n  --http [auto|1|2]               HTTP 版本  [环境变量: GRANIAN_HTTP; 默认: (auto)]\n  --ws / --no-ws                  启用websocket处理  [环境变量: GRANIAN_WEBSOCKETS; 默认: (启用)]\n  --workers INTEGER RANGE         工作进程数量  [环境变量: GRANIAN_WORKERS; 默认: 1; x&gt;=1]\n  --threads INTEGER RANGE         每个工作进程的线程数量  [环境变量: GRANIAN_THREADS; 默认: 1; x&gt;=1]\n  --blocking-threads INTEGER RANGE\n                                  每个工作进程的阻塞线程数量\n                                  [环境变量: GRANIAN_BLOCKING_THREADS; x&gt;=1]\n  --threading-mode [runtime|workers]\n                                  使用的线程模式  [环境变量: GRANIAN_THREADING_MODE; 默认: (workers)]\n  --loop [auto|asyncio|uvloop]    事件循环实现  [环境变量: GRANIAN_LOOP; 默认: (auto)]\n  --opt / --no-opt                启用循环优化  [环境变量: GRANIAN_LOOP_OPT; 默认: (禁用)]\n  --backlog INTEGER RANGE         全局最大连接等待数  [环境变量: GRANIAN_BACKLOG; 默认: 1024; x&gt;=128]\n  --backpressure INTEGER RANGE    每个工作进程并发处理的最大请求数  [环境变量: GRANIAN_BACKPRESSURE; 默认: (backlog/workers); x&gt;=1]\n  --http1-buffer-size INTEGER RANGE\n                                  设置HTTP/1连接的最大缓冲区大小  [环境变量: GRANIAN_HTTP1_BUFFER_SIZE; 默认: 417792; x&gt;=8192]\n  --http1-keep-alive / --no-http1-keep-alive\n                                  启用或禁用HTTP/1保持连接  [环境变量: GRANIAN_HTTP1_KEEP_ALIVE; 默认: (启用)]\n  --http1-pipeline-flush / --no-http1-pipeline-flush\n                                  聚合HTTP/1刷新以更好地支持管线化响应（实验性）  [环境变量: GRANIAN_HTTP1_PIPELINE_FLUSH; 默认: (禁用)]\n  --http2-adaptive-window / --no-http2-adaptive-window\n                                  设置是否对HTTP2使用自适应流控制  [环境变量: GRANIAN_HTTP2_ADAPTIVE_WINDOW; 默认: (禁用)]\n  --http2-initial-connection-window-size INTEGER\n                                  设置HTTP2的最大连接级流控制  [环境变量: GRANIAN_HTTP2_INITIAL_CONNECTION_WINDOW_SIZE; 默认: 1048576]\n  --http2-initial-stream-window-size INTEGER\n                                  设置HTTP2流级流控制的`SETTINGS_INITIAL_WINDOW_SIZE`选项\n                                  [环境变量: GRANIAN_HTTP2_INITIAL_STREAM_WINDOW_SIZE; 默认: 1048576]\n  --http2-keep-alive-interval INTEGER\n                                  设置应发送HTTP2 Ping帧以保持连接存活的间隔\n                                  [环境变量: GRANIAN_HTTP2_KEEP_ALIVE_INTERVAL]\n  --http2-keep-alive-timeout INTEGER\n                                  设置接收HTTP2保持连接ping的确认的超时时间\n                                  [环境变量: GRANIAN_HTTP2_KEEP_ALIVE_TIMEOUT; 默认: 20]\n  --http2-max-concurrent-streams INTEGER\n                                  设置HTTP2连接的SETTINGS_MAX_CONCURRENT_STREAMS选项  [环境变量: GRANIAN_HTTP2_MAX_CONCURRENT_STREAMS; 默认: 200]\n  --http2-max-frame-size INTEGER  设置HTTP2的最大帧大小  [环境变量: GRANIAN_HTTP2_MAX_FRAME_SIZE; 默认: 16384]\n  --http2-max-headers-size INTEGER\n                                  设置接收的头帧的最大大小\n                                  [环境变量: GRANIAN_HTTP2_MAX_HEADERS_SIZE; 默认: 16777216]\n  --http2-max-send-buffer-size INTEGER\n                                  设置每个HTTP/2流的最大写缓冲区大小  [环境变量: GRANIAN_HTTP2_MAX_SEND_BUFFER_SIZE; 默认: 409600]\n  --log / --no-log                启用日志记录  [环境变量: GRANIAN_LOG_ENABLED; 默认: (启用)]\n  --log-level [critical|error|warning|warn|info|debug]\n                                  日志级别  [环境变量: GRANIAN_LOG_LEVEL; 默认: (info)]\n  --log-config FILE               日志配置文件(json)  [环境变量: GRANIAN_LOG_CONFIG]\n  --access-log / --no-access-log  启用访问日志  [环境变量: GRANIAN_LOG_ACCESS_ENABLED; 默认: (禁用)]\n  --access-log-fmt TEXT           访问日志格式  [环境变量: GRANIAN_LOG_ACCESS_FMT]\n  --ssl-keyfile FILE              SSL密钥文件  [环境变量: GRANIAN_SSL_KEYFILE]\n  --ssl-certificate FILE          SSL证书文件  [环境变量: GRANIAN_SSL_CERTIFICATE]\n  --url-path-prefix TEXT          应用挂载的URL路径前缀  [环境变量: GRANIAN_URL_PATH_PREFIX]\n  --respawn-failed-workers / --no-respawn-failed-workers\n                                  启用意外退出的工作进程重生\n                                  [环境变量: GRANIAN_RESPAWN_FAILED_WORKERS; 默认: (禁用)]\n  --respawn-interval FLOAT        工作进程重生间隔秒数  [环境变量: GRANIAN_RESPAWN_INTERVAL; 默认: 3.5]\n  --reload / --no-reload          启用应用文件更改的自动重载（需要granian[reload]额外配置）\n                                  [环境变量: GRANIAN_RELOAD; 默认: (禁用)]\n  --process-name TEXT             设置进程的自定义名称（需要granian[pname]额外配置）  [环境变量: GRANIAN_PROCESS_NAME]\n  --version                       显示版本并退出。\n  --help                          显示这条帮助信息并退出。"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nUmami 分析网站访客\n\n\n\n\n\n\nweb\n\n\n\n\n\n\nJun 16, 2024\n\n\nLiripo\n\n\n1 min\n\n\n\n\n\n\n\n\n\n\n\n\ncadvisor + prometheus + grafana 容器资源监控\n\n\n\n\n\n\ncadvisor\n\n\nprometheus\n\n\ngrafana\n\n\n\n\n\n\nJun 16, 2024\n\n\nLiripo\n\n\n2 min\n\n\n\n\n\n\n\n\n\n\n\n\ngranian 部署 dash 生产环境\n\n\n\n\n\n\ndash\n\n\nweb\n\n\n\n\n\n\nJun 15, 2024\n\n\nLiripo\n\n\n8 min\n\n\n\n\n\n\n\n\n\n\n\n\ngunicorn 部署 dash 生产环境\n\n\n\n\n\n\ndash\n\n\nweb\n\n\n\n\n\n\nJun 15, 2024\n\n\nLiripo\n\n\n2 min\n\n\n\n\n\n\n\n\n\n\n\n\nquarto 创建博客\n\n\n\n\n\n\nquarto\n\n\n\n\n\n\nJan 2, 2024\n\n\nLiripo\n\n\n1 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/gunicorn_dash/index.html",
    "href": "posts/gunicorn_dash/index.html",
    "title": "gunicorn 部署 dash 生产环境",
    "section": "",
    "text": "使用 gunicorn 的好处是可以多进程以及热重载。\n\n\n首先 dash的代码，例如 app.py中必须包含下面代码\n\napp = Dash(__name__)\nserver = app.server # 这行代码需要包含在 dash 代码中\n\n设置配置文件，如 gunicorn.conf.py\n\nbind = '127.0.0.1:8000'      #绑定ip和端口号\n# chdir = ''  #gunicorn要切换到的目的工作目录\ntimeout = 30 #  指定工作进程在超过此时间未活动时被终止和重启，默认为 30 秒\n# worker_class = 'sync' #使用gevent模式，还可以使用sync 模式，默认的是sync模式\ndaemon = False # 后台运行\nworkers = 4 #进程数\nthreads = 4 #指定每个进程开启的线程数\nloglevel = 'info' #日志级别\naccess_log_format = '%(t)s %(p)s %(h)s \"%(r)s\" %(s)s %(L)s %(b)s %(f)s\" \"%(a)s\"'    #设置gunicorn访问日志格式，错误日志无法设置\n\n\naccesslog = \"/tmp/gunicorn/gunicorn_access.log\"      #访问日志文件\nerrorlog = \"/tmp/gunicorn/gunicorn_error.log\"        #错误日志文件\nreload = False # 如果需要在代码更改时自动重启，则改为True（主要用于开发）。如果要自己控制，则使用 kill -HUP {gunicorn 主进程id }\n\n启动程序\n\n# app表示当前目录下app.py的意思，server则是文件下的变量\ngunicorn app:server -c ./gunicorn.conf.py\n\n\n想要自己重启 gunicorn，可以向Gunicorn主进程发送HUP信号，这会导致Gunicorn平滑地重启所有工作进程，但不会关闭主进程。（适合在使用频率低的情况下，重启应用程序，而不影响其他人）\n\n查找主进程 pid\n\nps axjf | grep gunicorn\n\n\n\npid\n\n\n例如，上图主进程 pid 为 1674\nkill -HUP 1674\n\n\n\n上面的 HUP即为gunicorn支持的信号，下面为其他信号：\n\nQUIT, INT (Ctrl+C): 快速关闭。发送这个信号将立即关闭 Gunicorn 主进程和所有工作进程，不管它们当前是否在处理请求。这相当于一个强制退出操作。\nTERM: 优雅关闭。这个信号会告诉 Gunicorn 主进程开始优雅地关闭，它会等待当前正在处理的请求完成，直到达到 graceful_timeout（优雅超时）设置的时间。一旦所有请求处理完毕，Gunicorn 将关闭主进程和所有工作进程。\nHUP: 重新加载配置。当收到 HUP 信号时，Gunicorn 主进程会重新加载配置文件，并以新的配置启动新的工作进程。如果应用程序没有预加载（使用 preload_app 选项），Gunicorn 还会加载应用程序的新版本。老的工作进程将会优雅地关闭。\nTTIN: 增加进程数。当收到 TTIN 信号时，Gunicorn 主进程将增加工作进程的数量。\nTTOU: 减少进程数。当收到 TTOU 信号时，Gunicorn 主进程将减少工作进程的数量。\nUSR1: 重新打开日志文件。发送这个信号将告诉 Gunicorn 主进程重新打开所有日志文件。\nUSR2: 在运行时升级 Gunicorn。发送这个信号将告诉 Gunicorn 主进程使用新的二进制文件进行升级。一个额外的 TERM 信号应该用来杀死旧的主进程。这个信号也可以用来在运行时使用预加载应用程序的新版本。\nWINCH: 守护进程的优雅关闭。当 Gunicorn 以守护进程运行时，收到 WINCH 信号将优雅地关闭工作进程。 注：TERM 和 WINCH 信号都可以用于关闭 Gunicorn 服务器，但它们在关闭方式上有一些区别：\n\n\n\n\n\n\n\nNote\n\n\n\n\nTERM 信号：\n\n作用：TERM 信号告诉 Gunicorn 主进程开始优雅地关闭工作进程。它会等待当前正在处理的请求完成后再关闭工作进程，从而确保不会丢失客户端请求。\n使用场景：TERM 信号通常在需要优雅地关闭 Gunicorn 服务器时使用，以确保不会中断正在处理的请求。\n\nWINCH 信号：\n\n作用：WINCH 信号通常在 Gunicorn 以守护进程模式运行时使用，用于实现优雅地关闭工作进程。它会等待当前正在处理的请求完成，然后再关闭工作进程。\n使用场景：WINCH 信号通常在希望停止 Gunicorn 服务器并且希望等待当前正在处理的请求完成后再关闭工作进程时使用，特别是在守护进程模式下运行时。\n\n\n总的来说，TERM 信号更适合在普通情况下优雅地关闭 Gunicorn 服务器，而 WINCH 信号则更适合在守护进程模式下使用，以实现更加平滑的关闭过程。\n\n\n\n\n\npid"
  },
  {
    "objectID": "posts/gunicorn_dash/index.html#使用-gunicorn-部署-dash",
    "href": "posts/gunicorn_dash/index.html#使用-gunicorn-部署-dash",
    "title": "gunicorn 部署 dash 生产环境",
    "section": "",
    "text": "使用 gunicorn 的好处是可以多进程以及热重载。\n\n\n首先 dash的代码，例如 app.py中必须包含下面代码\n\napp = Dash(__name__)\nserver = app.server # 这行代码需要包含在 dash 代码中\n\n设置配置文件，如 gunicorn.conf.py\n\nbind = '127.0.0.1:8000'      #绑定ip和端口号\n# chdir = ''  #gunicorn要切换到的目的工作目录\ntimeout = 30 #  指定工作进程在超过此时间未活动时被终止和重启，默认为 30 秒\n# worker_class = 'sync' #使用gevent模式，还可以使用sync 模式，默认的是sync模式\ndaemon = False # 后台运行\nworkers = 4 #进程数\nthreads = 4 #指定每个进程开启的线程数\nloglevel = 'info' #日志级别\naccess_log_format = '%(t)s %(p)s %(h)s \"%(r)s\" %(s)s %(L)s %(b)s %(f)s\" \"%(a)s\"'    #设置gunicorn访问日志格式，错误日志无法设置\n\n\naccesslog = \"/tmp/gunicorn/gunicorn_access.log\"      #访问日志文件\nerrorlog = \"/tmp/gunicorn/gunicorn_error.log\"        #错误日志文件\nreload = False # 如果需要在代码更改时自动重启，则改为True（主要用于开发）。如果要自己控制，则使用 kill -HUP {gunicorn 主进程id }\n\n启动程序\n\n# app表示当前目录下app.py的意思，server则是文件下的变量\ngunicorn app:server -c ./gunicorn.conf.py\n\n\n想要自己重启 gunicorn，可以向Gunicorn主进程发送HUP信号，这会导致Gunicorn平滑地重启所有工作进程，但不会关闭主进程。（适合在使用频率低的情况下，重启应用程序，而不影响其他人）\n\n查找主进程 pid\n\nps axjf | grep gunicorn\n\n\n\npid\n\n\n例如，上图主进程 pid 为 1674\nkill -HUP 1674\n\n\n\n上面的 HUP即为gunicorn支持的信号，下面为其他信号：\n\nQUIT, INT (Ctrl+C): 快速关闭。发送这个信号将立即关闭 Gunicorn 主进程和所有工作进程，不管它们当前是否在处理请求。这相当于一个强制退出操作。\nTERM: 优雅关闭。这个信号会告诉 Gunicorn 主进程开始优雅地关闭，它会等待当前正在处理的请求完成，直到达到 graceful_timeout（优雅超时）设置的时间。一旦所有请求处理完毕，Gunicorn 将关闭主进程和所有工作进程。\nHUP: 重新加载配置。当收到 HUP 信号时，Gunicorn 主进程会重新加载配置文件，并以新的配置启动新的工作进程。如果应用程序没有预加载（使用 preload_app 选项），Gunicorn 还会加载应用程序的新版本。老的工作进程将会优雅地关闭。\nTTIN: 增加进程数。当收到 TTIN 信号时，Gunicorn 主进程将增加工作进程的数量。\nTTOU: 减少进程数。当收到 TTOU 信号时，Gunicorn 主进程将减少工作进程的数量。\nUSR1: 重新打开日志文件。发送这个信号将告诉 Gunicorn 主进程重新打开所有日志文件。\nUSR2: 在运行时升级 Gunicorn。发送这个信号将告诉 Gunicorn 主进程使用新的二进制文件进行升级。一个额外的 TERM 信号应该用来杀死旧的主进程。这个信号也可以用来在运行时使用预加载应用程序的新版本。\nWINCH: 守护进程的优雅关闭。当 Gunicorn 以守护进程运行时，收到 WINCH 信号将优雅地关闭工作进程。 注：TERM 和 WINCH 信号都可以用于关闭 Gunicorn 服务器，但它们在关闭方式上有一些区别：\n\n\n\n\n\n\n\nNote\n\n\n\n\nTERM 信号：\n\n作用：TERM 信号告诉 Gunicorn 主进程开始优雅地关闭工作进程。它会等待当前正在处理的请求完成后再关闭工作进程，从而确保不会丢失客户端请求。\n使用场景：TERM 信号通常在需要优雅地关闭 Gunicorn 服务器时使用，以确保不会中断正在处理的请求。\n\nWINCH 信号：\n\n作用：WINCH 信号通常在 Gunicorn 以守护进程模式运行时使用，用于实现优雅地关闭工作进程。它会等待当前正在处理的请求完成，然后再关闭工作进程。\n使用场景：WINCH 信号通常在希望停止 Gunicorn 服务器并且希望等待当前正在处理的请求完成后再关闭工作进程时使用，特别是在守护进程模式下运行时。\n\n\n总的来说，TERM 信号更适合在普通情况下优雅地关闭 Gunicorn 服务器，而 WINCH 信号则更适合在守护进程模式下使用，以实现更加平滑的关闭过程。\n\n\n\n\n\npid"
  },
  {
    "objectID": "posts/umami/index.html",
    "href": "posts/umami/index.html",
    "title": "Umami 分析网站访客",
    "section": "",
    "text": "如上图所示，我们可以通过 Umami Cloud 分析网站访客。\n\nUmami Cloud免费套餐可以监控三个网站，10k/mouth 的访客数，对于博客，完全够用了。如果不够用的，Umami 也支持本地部署。\n\n\n注册Umami Cloud, 之后填写要分析的网站，填写完成后会给出对应的追踪代码；\n给要分析的网站，增加追踪代码：\n\n&lt;script defer src=\"https://cloud.umami.is/script.js\" data-website-id=\"6aca168c-471e-41f9-9977-ac136a20c1c1\"&gt;&lt;/script&gt;\n上面代码data-website-id='*'记得改为对应的追踪 id。"
  },
  {
    "objectID": "posts/umami/index.html#umami-cloud-监控网站",
    "href": "posts/umami/index.html#umami-cloud-监控网站",
    "title": "Umami 分析网站访客",
    "section": "",
    "text": "如上图所示，我们可以通过 Umami Cloud 分析网站访客。\n\nUmami Cloud免费套餐可以监控三个网站，10k/mouth 的访客数，对于博客，完全够用了。如果不够用的，Umami 也支持本地部署。\n\n\n注册Umami Cloud, 之后填写要分析的网站，填写完成后会给出对应的追踪代码；\n给要分析的网站，增加追踪代码：\n\n&lt;script defer src=\"https://cloud.umami.is/script.js\" data-website-id=\"6aca168c-471e-41f9-9977-ac136a20c1c1\"&gt;&lt;/script&gt;\n上面代码data-website-id='*'记得改为对应的追踪 id。"
  }
]